[f:\Github\DaGameThatIsFun\Python\System\utils.py]
import time
from typing import Dict
from System.models import LobbySession

def cleanup_inactive_lobbies(active_sessions: Dict[str, LobbySession]):
    while True:
        current_time = time.time()
        to_remove = []
        
        for code, lobby in active_sessions.items():
            if current_time - lobby.created_at > 7200:  # 2 heures
                to_remove.append(code)
                
        for code in to_remove:
            del active_sessions[code]
            
        time.sleep(300)


[f:\Github\DaGameThatIsFun\Python\System\server.py]
import http.server
import socketserver
import ujson as json
import threading
import time
from System.models import LobbySession
from System.lobby import active_sessions, create_lobby, join_lobby, leave_lobby
from System.qr import get_local_ip, generate_qr_code

active_sessions_lock = threading.Lock()
PORT = 8080
DIRECTORY = "Files"

class LobbyHandler(http.server.SimpleHTTPRequestHandler):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, directory=DIRECTORY, **kwargs)

    def end_headers(self):
        if self.path.startswith('/api'):
            self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')
        else:
            self.send_header('Cache-Control', 'max-age=3600')
        super().end_headers()

    def send_json_response(self, data, status=200):
        self.send_response(status)
        self.send_header('Content-type', 'application/json')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.end_headers()
        self.wfile.write(json.dumps(data).encode())

    def send_error_response(self, message, status=400):
        self.send_json_response({'error': message, 'success': False}, status)

    def do_OPTIONS(self):
        self.send_response(200)
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, DELETE, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        self.end_headers()

    def do_POST(self):
        content_length = int(self.headers.get('Content-Length', 0))
        post_data = {}
        if content_length > 0:
            post_data = json.loads(self.rfile.read(content_length).decode('utf-8'))
        client_ip = self.client_address[0]
        try:
            if self.path == '/api/lobby/create':
                response = create_lobby(
                    post_data.get('playerName'),
                    post_data.get('password'),
                    post_data.get('avatarIndex', 0),
                    post_data.get('maxPlayers', 8),
                    client_ip
                )
                self.send_json_response(response)
            elif self.path == '/api/lobby/join':
                response = join_lobby(
                    post_data.get('roomCode'),
                    post_data.get('playerName'),
                    post_data.get('password'),
                    post_data.get('avatarIndex', 0),
                    client_ip
                )
                self.send_json_response(response)
            elif self.path.startswith('/api/lobby/') and self.path.endswith('/leave'):
                room_code = self.path.split('/')[-2]
                response = leave_lobby(post_data.get('userId'), room_code)
                self.send_json_response(response)
            elif self.path.startswith('/api/lobby/') and self.path.endswith('/command'):
                room_code = self.path.split('/')[-2]
                with active_sessions_lock:
                    if room_code not in active_sessions:
                        raise ValueError("Salon introuvable")
                    lobby = active_sessions[room_code]
                    if post_data.get('initiator') != lobby.owner:
                        self.send_error_response("Action non autorisée", 403)
                        return
                    command = post_data.get('command')
                    if command == 'start-game':
                        lobby.latest_command = {
                            'command': 'redirect',
                            'payload': {
                                'url': post_data.get('payload').get('gameUrl'),
                                'force': True
                            },
                            'timestamp': time.time(),
                            'initiator': lobby.owner
                        }
                    else:
                        if command == 'redirect' and post_data.get('payload') and post_data.get('payload').get('newState'):
                            lobby.state = post_data.get('payload').get('newState')
                        lobby.latest_command = {
                            'command': command,
                            'payload': post_data.get('payload'),
                            'timestamp': time.time(),
                            'initiator': lobby.owner
                        }
                self.send_json_response({'success': True})
            else:
                self.send_error_response("Endpoint non trouvé", 404)
        except Exception as e:
            self.send_error_response(str(e))

    def do_GET(self):
        try:
            base_path = self.path.split('?')[0]
            if base_path == '/get_ip':
                ip = get_local_ip()
                qr_code = generate_qr_code(ip, PORT)
                self.send_json_response({
                    "url": f"http://{ip}:{PORT}",
                    "qr_code": qr_code
                })
            elif base_path == '/api/lobbies':
                lobbies_data = []
                with active_sessions_lock:
                    for session in active_sessions.values():
                        lobby_data = session.to_dict()
                        lobby_data['latest_command'] = getattr(session, 'latest_command', None)
                        lobbies_data.append(lobby_data)
                self.send_json_response({'lobbies': lobbies_data})
            elif base_path.startswith('/api/lobby/') and len(base_path.split('/')) == 4:
                room_code = base_path.split('/')[-1]
                from urllib.parse import urlparse, parse_qs
                query = parse_qs(urlparse(self.path).query)
                user_id = query.get('userId', [None])[0]
                with active_sessions_lock:
                    if room_code in active_sessions:
                        lobby = active_sessions[room_code]
                        if user_id and user_id in lobby.users:
                            lobby.users[user_id].last_seen = time.time()
                        lobby_data = lobby.to_dict()
                        lobby_data['latest_command'] = getattr(lobby, 'latest_command', None)
                        self.send_json_response(lobby_data)
                    else:
                        self.send_error_response("Salon non trouvé", 404)
            else:
                super().do_GET()
        except Exception as e:
            self.send_error_response(str(e))

    def do_DELETE(self):
        if self.path.startswith('/api/lobby/delete/'):
            room_code = self.path.split('/')[-1]
            with active_sessions_lock:
                if room_code in active_sessions:
                    del active_sessions[room_code]
                    self.send_json_response({'success': True})
                else:
                    self.send_error_response("Le salon n'existe pas", 404)
        else:
            self.send_error_response("Endpoint non trouvé", 404)

def run_server():
    with socketserver.ThreadingTCPServer(("", PORT), LobbyHandler) as httpd:
        httpd.serve_forever()

if __name__ == "__main__":
    run_server()


[f:\Github\DaGameThatIsFun\Python\System\models.py]
# models.py
from dataclasses import dataclass, field
from typing import Dict, Optional
import threading, time

@dataclass
class User:
    id: str
    name: str
    avatar_index: int
    join_time: float
    ip_address: str
    last_seen: float = field(default_factory=lambda: time.time())

@dataclass
class LobbySession:
    code: str
    name: str
    owner: str
    password: Optional[str]
    users: Dict[str, User]
    created_at: float
    max_players: int
    state: str = "waiting"
    lock: threading.Lock = field(default_factory=threading.Lock)
    
    def to_dict(self):
        with self.lock:
            return {
                'code': self.code,
                'name': self.name,
                'owner': self.owner,
                'hasPassword': bool(self.password),
                'users': {uid: {
                    'id': u.id,
                    'name': u.name,
                    'avatar_index': u.avatar_index,
                    'join_time': u.join_time,
                    'ip_address': u.ip_address,
                    'last_seen': u.last_seen
                } for uid, u in self.users.items()},
                'created_at': self.created_at,
                'max_players': self.max_players,
                'state': self.state  
            }


[f:\Github\DaGameThatIsFun\Python\System\lobby.py]
import random
import string
import time
import threading
from typing import Dict, Optional
from System.models import LobbySession, User

active_sessions: Dict[str, LobbySession] = {}
active_sessions_lock = threading.Lock()
INACTIVITY_THRESHOLD = 90
def generate_code() -> str:
    while True:
        code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=4))
        with active_sessions_lock:
            if code not in active_sessions:
                return code
def create_lobby(player_name: str, password: Optional[str], avatar_index: int, max_players: int, client_ip: str) -> dict:
    if not player_name:
        raise ValueError("Le nom du joueur est requis")
    if max_players not in range(2, 9):
        raise ValueError("Le nombre de joueurs doit être entre 2 et 8")
    room_code = generate_code()
    user_id = str(random.randint(10000, 99999))
    owner = User(
        id=user_id,
        name=player_name,
        avatar_index=avatar_index,
        join_time=time.time(),
        ip_address=client_ip
    )
    lobby_session = LobbySession(
        code=room_code,
        name=f"Salon de {player_name}",
        owner=user_id,
        password=password,
        users={user_id: owner},
        created_at=time.time(),
        max_players=max_players
    )
    with active_sessions_lock:
        active_sessions[room_code] = lobby_session
    return {'success': True, 'roomCode': room_code, 'userId': user_id, 'sessionData': lobby_session.to_dict()}
def join_lobby(room_code: str, player_name: str, password: Optional[str], avatar_index: int, client_ip: str) -> dict:
    if not room_code or not player_name:
        raise ValueError("Le code du salon et le nom du joueur sont requis")
    with active_sessions_lock:
        if room_code not in active_sessions:
            raise ValueError("Le salon n'existe pas")
        lobby = active_sessions[room_code]
    with lobby.lock:
        if lobby.password and lobby.password != password:
            raise ValueError("Mot de passe incorrect")
        if len(lobby.users) >= lobby.max_players:
            raise ValueError("Le salon est plein")
        user_id = str(random.randint(10000, 99999))
        new_user = User(
            id=user_id,
            name=player_name,
            avatar_index=avatar_index,
            join_time=time.time(),
            ip_address=client_ip
        )
        lobby.users[user_id] = new_user
    return {'success': True, 'userId': user_id, 'sessionData': lobby.to_dict()}
def leave_lobby(user_id: str, room_code: str) -> dict:
    if room_code not in active_sessions:
        return {'success': False, 'error': "Le salon n'existe pas"}
    lobby = active_sessions[room_code]
    if user_id in lobby.users:
        del lobby.users[user_id]
    if user_id == lobby.owner:
        print(f"L'owner du lobby {room_code} a quitté, suppression du lobby.")
        del active_sessions[room_code]
    elif not lobby.users:
        print(f"Le lobby {room_code} est vide et sera supprimé.")
        del active_sessions[room_code]
    return {'success': True}
def cleanup_inactive_users():
    while True:
        time.sleep(10)
        current_time = time.time()
        with active_sessions_lock:
            for room_code in list(active_sessions.keys()):
                lobby = active_sessions[room_code]
                with lobby.lock:
                    inactive_users = []
                    for user_id, user in lobby.users.items():
                        if current_time - user.last_seen > INACTIVITY_THRESHOLD:
                            inactive_users.append(user_id)
                    for user_id in inactive_users:
                        del lobby.users[user_id]
                        print(f"[CLEANUP] Utilisateur {user_id} retiré du salon {room_code} pour inactivité.")
                    if lobby.owner in inactive_users:
                        print(f"[CLEANUP] Propriétaire {lobby.owner} inactif, suppression du salon {room_code}.")
                        del active_sessions[room_code]
                    elif not lobby.users:
                        print(f"[CLEANUP] Salon {room_code} vide, suppression.")
                        del active_sessions[room_code]
cleanup_thread = threading.Thread(target=cleanup_inactive_users, daemon=True)
cleanup_thread.start()


[f:\Github\DaGameThatIsFun\Files\index.html]
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Party Game Lobby</title>
  <link rel="stylesheet" href="/static/style.css">
  <link rel="stylesheet" href="/static/mobile_style.css">
  <link rel="stylesheet" href="/static/lobby_style.css">
  <link rel="icon" type="image/png" href="/static/images/favicon/favicon.png">
</head>
<body>
  <button class="share-control" id="shareToggle">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="white">
      <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92S19.61 16.08 18 16.08z"/>
    </svg>
  </button>
  <button class="sound-control" id="soundToggle">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
      <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
      <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
    </svg>
  </button>
  <div id="qrCodeModal" class="modal-overlay">
    <div class="modal-container">
      <h2 class="modal-title">Partager le lien</h2>
      <div class="modal-content">
        <p id="qrCodeUrl" style="word-break: break-all; margin-bottom: 1rem;"></p>
        <img id="qrCodeImage" alt="QR Code" style="width: 200px; height: 200px; margin: 0 auto;">
        <div style="margin-top: 1rem; text-align: center;">
          <button class="modal-button modal-button-secondary">Copier le lien</button>
        </div>
      </div>
      <div class="modal-buttons">
        <button class="modal-button modal-button-primary">Fermer</button>
      </div>
    </div>
  </div>
  <div class="bg"></div>
  <div id="introScreen" class="intro-screen">
    <div class="intro-content">
      <img src="/static/images/logo/logo.png" alt="Party Game Logo" class="intro-logo">
      <p class="intro-text">Avertissement !</p>
    </div>
    <div class="security-text">
      Veuillez noter que ce jeu peut contenir du contenu grossier ou inapproprié pour certains publics.<br><br>
      Ce n’est en aucun cas notre intention de blesser quiconque, il s’agit simplement d’un jeu conçu pour s’amuser et rire ensemble :)
    </div>
  </div>
  <div class="logo-container">
    <img src="/static/images/logo/logo.png" alt="Party Game Logo" class="logo">
  </div>
  <div class="container">
    <div class="grid">
      <div>
        <div class="game-buttons">
          <button class="game-button active" data-game="draw-contest">
            <img src="/static/images/logo/draw-contest.png" alt="Draw Contest" class="game-logo">
          </button>
          <button class="game-button" data-game="pictionary">
            <img src="/static/images/logo/pictionary.png" alt="Pictionary" class="game-logo">
          </button>
          <button class="game-button" data-game="quiz-rush">
            <img src="/static/images/logo/quiz-rush.png" alt="Quiz Rush" class="game-logo">
          </button>
          <button class="game-button" data-game="object-tales" disabled>
            <img src="/static/images/logo/object-tales-disabled.png" alt="Object Tales" class="game-logo">
          </button>
        </div>
      </div>
      <div class="preview-card">
        <div class="tv-static"></div>
        <img src="/static/images/preview/draw-contest.png" alt="Game Preview" class="preview-image" id="previewImage">
        <div class="preview-content">
          <h3 class="preview-title" id="previewTitle">Dessine moi un Désastre</h3>
          <p class="preview-description" id="previewDescription">
            Une phrase loufoque, des dessins absurdes, et un vote pour élire l'œuvre la plus iconique. À vos pinceaux, le massacre commence !
          </p>
          <p class="preview-player-number" id="previewPlayerNumber">4-8 Joueurs</p>
          <button class="preview-button" id="previewButton" style="display: none;" disabled>
            Lancer le jeu !
          </button>
        </div>
      </div>
    </div>
    <div class="bottom-actions" id="bottomActions"></div>
    
  </div><div id="playersContainer"></div>

  <audio id="staticSound" src="/static/music/tv-static.mp3"></audio>
  
  <script type="module" src="javascript/index.js"></script>
  <script type="module">
    import { initShareButton} from './javascript/button_controls.js';
    document.addEventListener("DOMContentLoaded", () => {
      initShareButton();
    });
  </script>
</body>
</html>


[f:\Github\DaGameThatIsFun\Files\waiting_room.html]
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Salon d'attente</title>
  <link rel="stylesheet" href="/static/style.css">
  <link rel="stylesheet" href="/static/mobile_style.css">
  <link rel="icon" type="image/png" href="/static/images/favicon/favicon.png">
  <style>
    /* Styles spécifiques pour l'overlay du compte à rebours et la modal */
    .modal-overlay, .countdown-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .modal-container, .countdown-content {
      background: #fff;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
    }
    .modal-buttons button, .countdown-content button {
      margin: 5px;
    }
  </style>
</head>
<body>
  <!-- Contrôles généraux -->
  <button class="share-control" id="shareToggle">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="white">
    <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92S19.61 16.08 18 16.08z"/>
    </svg>
</button>
<div id="qrCodeModal" class="modal-overlay">
    <div class="modal-container">
    <h2 class="modal-title">Partager le lien</h2>
    <div class="modal-content">
        <p id="qrCodeUrl" style="word-break: break-all; margin-bottom: 1rem;"></p>
        <img id="qrCodeImage" alt="QR Code" style="width: 200px; height: 200px; margin: 0 auto;">
        <div style="margin-top: 1rem; text-align: center;">
        <button onclick="copyLink()" class="modal-button modal-button-secondary">Copier le lien</button>
        </div>
    </div>
    <div class="modal-buttons">
        <button class="modal-button modal-button-primary" onclick="hideModal('qrCodeModal')">Fermer</button>
    </div>
    </div>
</div>

  <div class="bg"></div>
  <div class="logo-container">
    <img src="/static/images/logo/logo.png" alt="Party Game Logo" class="logo">
  </div>

  <div class="container">
    <div class="waiting-room">
      <div class="room-info">
        <h2 class="title">Salon d'attente</h2>
        <div class="room-code">
          CODE: <span id="roomCode"></span>
        </div>
      </div>

      <div class="players-grid" id="playersGrid">
        <!-- Les joueurs seront ajoutés ici dynamiquement -->
      </div>

      <div class="button-container">
        <button type="button" class="button button-secondary" id="leaveButton">Quitter le salon</button>
        <button type="button" class="button button-primary" id="startButton" disabled>
          Lancer la partie (1/8)
        </button>
      </div>
    </div>
  </div>

  <!-- Modal de confirmation pour quitter le salon -->
  <div class="modal-overlay" id="confirmationModal">
    <div class="modal-container">
      <h2 class="modal-title">Quitter le Salon ?</h2>
      <div class="modal-content">
        <p id="modalMessage">Êtes-vous sûr de vouloir quitter le salon ?</p>
      </div>
      <div class="modal-buttons">
        <button class="modal-button modal-button-secondary" id="cancelButton">Annuler</button>
        <button class="modal-button modal-button-primary" id="confirmButton">Confirmer</button>
      </div>
    </div>
  </div>

  <!-- Overlay de compte à rebours -->
  <div class="countdown-overlay" id="countdownOverlay">
    <div class="countdown-content">
      <div id="countdownNumber" class="countdown-number">3</div>
      <!-- Bouton "Annuler" visible uniquement pour l'owner -->
      <button type="button" id="cancelCountdown" class="button button-secondary">Annuler</button>
    </div>
  </div>

  <script type="module" src="/Javascript/waiting_room.js"></script>
  <script type="module" src="javascript/button_controls.js"></script>
  <script type="module">
    import { initShareButton} from './javascript/button_controls.js';
    document.addEventListener("DOMContentLoaded", () => {
      initShareButton();
    });
  </script>
</body>
</html>


[f:\Github\DaGameThatIsFun\Files\Javascript\waiting_room.js]
import { LobbyManager } from './lobby_manager.js';
let isOwner = false;
const userId = localStorage.getItem('userId');
const roomCode = localStorage.getItem('roomCode');
if (!roomCode || !userId) {
  window.location.href = '/';
}
const modal = document.getElementById('confirmationModal');
const leaveButton = document.getElementById('leaveButton');
const cancelButton = document.getElementById('cancelButton');
const confirmButton = document.getElementById('confirmButton');
const modalMessage = document.getElementById('modalMessage');
function showModal(message, ownerLeaving = false) {
  modalMessage.textContent = message;
  modal.style.display = 'flex';
  confirmButton.onclick = async () => {
    if (ownerLeaving) {
      await LobbyManager.sendCommandToPlayers('lobby-deleted');
      await LobbyManager.leaveLobby();
      window.location.href = '/';
    } else {
      await LobbyManager.leaveLobby();
      window.location.href = '/';
    }
  };
}
function hideModal() {
  modal.style.display = 'none';
}
leaveButton.addEventListener('click', () => {
  showModal(isOwner ? "Attention ! En quittant, le salon sera supprimé. Continuer ?" : "Quitter le salon ?", isOwner);
});
cancelButton.addEventListener('click', hideModal);
modal.addEventListener('click', (e) => {
  if (e.target === modal) hideModal();
});
function updatePlayersGrid(users, ownerId) {
  const playersGrid = document.getElementById('playersGrid');
  playersGrid.innerHTML = '';
  const currentUserId = localStorage.getItem('userId');
  const sortedUsers = Object.values(users).sort((a, b) => {
    if (a.id === ownerId) return -1;
    if (b.id === ownerId) return 1;
    return a.join_time - b.join_time;
  });
  for (let i = 0; i < 8; i++) {
    const playerSlot = document.createElement('div');
    playerSlot.classList.add('player-slot');
    if (i < sortedUsers.length) {
      const user = sortedUsers[i];
      playerSlot.innerHTML = `
        <div class="player-avatar${user.id === currentUserId ? ' current-player' : ''}">
          <img src="/static/images/avatar/${user.avatar_index + 1}.png" alt="${user.name}">
        </div>
        <span class="waiting-text">
          <strong>${user.name}</strong>
          ${user.id === ownerId ? ' 👑' : ''}
          ${user.id === currentUserId ? ' (Vous)' : ''}
        </span>`;
    } else {
      playerSlot.innerHTML = `
        <div class="player-avatar empty">
          <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="#9ca3af" stroke-width="2">
            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
            <circle cx="12" cy="7" r="4"></circle>
          </svg>
        </div>
        <span class="waiting-text">En attente...</span>`;
    }
    playersGrid.appendChild(playerSlot);
  }
}
function updateStartButton(userCount, maxPlayers) {
  const startButton = document.getElementById('startButton');
  startButton.textContent = `Lancer la partie (${userCount}/${maxPlayers})`;
  startButton.disabled = !isOwner || userCount < 2;
}
let countdownInterval;
function startCountdown(duration) {
  const countdownOverlay = document.getElementById('countdownOverlay');
  const countdownNumber = document.getElementById('countdownNumber');
  const cancelCountdown = document.getElementById('cancelCountdown');
  countdownOverlay.style.display = 'flex';
  let counter = duration;
  cancelCountdown.style.display = isOwner ? 'block' : 'none';
  countdownNumber.textContent = counter;
  countdownInterval = setInterval(() => {
    counter--;
    countdownNumber.textContent = counter < 0 ? 0 : counter;
    if (counter <= 0) {
      clearInterval(countdownInterval);
      sessionStorage.setItem('isRedirecting', 'true');
      LobbyManager.sendCommandToPlayers('redirect', {
        url: `index.html?roomCode=${roomCode}`
      });
    }
  }, 1000);
}
document.addEventListener('start-countdown', (e) => {
  const { duration } = e.detail;
  startCountdown(duration);
});
document.addEventListener('cancel-countdown', () => {
  clearInterval(countdownInterval);
  document.getElementById('countdownOverlay').style.display = 'none';
});
async function checkOwnerStatus() {
  try {
    const lobby = await LobbyManager.getCurrentLobby();
    if (!lobby) {
      window.location.href = 'index.html';
      return;
    }
    isOwner = lobby.isOwner;
    updatePlayersGrid(lobby.users, lobby.owner);
    updateStartButton(Object.keys(lobby.users).length, lobby.max_players || 8);
  } catch (error) {
    console.error("[WAITING] Erreur:", error);
  }
}
document.addEventListener('DOMContentLoaded', async () => {
  document.getElementById('roomCode').textContent = roomCode;
  LobbyManager.init();
  await checkOwnerStatus();
  setInterval(checkOwnerStatus, 1000);
  document.getElementById('startButton').addEventListener('click', () => {
    if (isOwner) {
      sessionStorage.setItem('isRedirecting', 'true');
      LobbyManager.sendCommandToPlayers('start-countdown', { duration: 5 });
      startCountdown(5);
    }
  });
});
window.addEventListener('beforeunload', async () => {
  if (!sessionStorage.getItem('isRedirecting')) {
    const roomCode = localStorage.getItem('roomCode');
    const userId = localStorage.getItem('userId');
    if (roomCode && userId) {
      const data = { userId };
      const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
      navigator.sendBeacon(`/api/lobby/${roomCode}/leave`, blob);
    }
  }
});


[f:\Github\DaGameThatIsFun\Files\Javascript\lobby_manager.js]
import { lobbyCommands } from './lobby_commands.js';

class LobbyManager {
  static POLL_INTERVAL = 1000;
  static MAX_POLL_INTERVAL = 30000;
  static POLL_BACKOFF_FACTOR = 1.5;
  static _currentPollInterval = this.POLL_INTERVAL;
  static _pollTimeout = null;
  static _listeners = new Set();
  static _errorCount = 0;
  static _MAX_ERRORS = 5;
  static _lastProcessedCommand = null;

  static init() {
    if (localStorage.getItem("roomCode")) {
      this.startPolling();
      this.setupCommandListener();
    }
    this._setupUnloadListener();
  }

  static _setupUnloadListener() {
    window.addEventListener("beforeunload", () => {
      const isRedirecting = sessionStorage.getItem("isRedirecting");
      const roomCode = localStorage.getItem("roomCode");
      const userId = localStorage.getItem("userId");
      if (!isRedirecting && roomCode && userId) {
        const data = { userId };
        const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
        navigator.sendBeacon(`/api/lobby/${roomCode}/leave`, blob);
      }
      sessionStorage.removeItem("isRedirecting");
    });
  }

  static async getActivePlayers() {
    const userId = localStorage.getItem("userId");
    const lobby = await this.getCurrentLobby();
    if (lobby) {
      return Object.values(lobby.users)
        .sort((a, b) => a.join_time - b.join_time)
        .map((user) => ({
          id: user.id,
          name: user.name,
          avatar: `/static/images/avatar/${user.avatar_index + 1}.png`,
          isOwner: user.id === lobby.owner,
          isCurrentUser: user.id === userId
        }));
    }
    return [];
  }

  static startPolling() {
    if (this._pollTimeout !== null) return;
    this._pollLobby();
  }

  static stopPolling() {
    if (this._pollTimeout) {
      clearTimeout(this._pollTimeout);
      this._pollTimeout = null;
    }
  }

  static addListener(callback) {
    this._listeners.add(callback);
    return () => this._listeners.delete(callback);
  }

  static async _pollLobby() {
    try {
      const lobby = await this.getCurrentLobby();
      if (lobby) {
        this._errorCount = 0;
        this._currentPollInterval = this.POLL_INTERVAL;
        this._notifyListeners(lobby);
        this.updatePlayers(lobby);
      } else {
        this.stopPolling();
        return;
      }
    } catch (error) {
      this._errorCount++;
      if (this._errorCount >= this._MAX_ERRORS) {
        this.stopPolling();
        return;
      }
      this._currentPollInterval = Math.min(this._currentPollInterval * this.POLL_BACKOFF_FACTOR, this.MAX_POLL_INTERVAL);
    } finally {
      if (this._pollTimeout !== null) {
        this._pollTimeout = setTimeout(() => this._pollLobby(), this._currentPollInterval);
      }
    }
  }

  static _notifyListeners(lobby) {
    for (const listener of this._listeners) {
      listener(lobby);
    }
  }

  static async getCurrentLobby() {
    const roomCode = localStorage.getItem("roomCode");
    const userId = localStorage.getItem("userId");
    if (!roomCode || !userId) return null;
    try {
      const response = await fetch(`/api/lobby/${roomCode}?userId=${userId}`);
      if (!response.ok) {
        if (response.status === 404) {
          localStorage.removeItem("roomCode");
          localStorage.removeItem("userId");
          this.stopPolling();
        }
        return null;
      }
      const data = await response.json();
      return {
        ...data,
        isOwner: data.owner === userId,
        currentUser: data.users[userId]
      };
    } catch (error) {
      return null;
    }
  }

  static async isCurrentUserOwner() {
    const lobby = await this.getCurrentLobby();
    return lobby?.isOwner || false;
  }

  static async leaveLobby() {
    const roomCode = localStorage.getItem("roomCode");
    const userId = localStorage.getItem("userId");
    if (roomCode && userId) {
      try {
        await fetch(`/api/lobby/${roomCode}/leave`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ userId })
        });
      } catch (error) {}
    }
    localStorage.removeItem("roomCode");
    localStorage.removeItem("userId");
    this.stopPolling();
  }

  static async sendCommandToPlayers(command, payload = {}) {
    const roomCode = localStorage.getItem("roomCode");
    const lobby = await this.getCurrentLobby();
    if (lobby?.isOwner) {
      try {
        const commandData = {
          command,
          initiator: localStorage.getItem("userId"),
          payload,
          timestamp: Date.now()
        };
        await fetch(`/api/lobby/${roomCode}/command`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(commandData)
        });
        if (lobbyCommands[command]) {
          lobbyCommands[command](payload, this);
        }
      } catch (error) {}
    }
  }

  static async startGame(gameUrl) {
    const roomCode = localStorage.getItem("roomCode");
    const lobby = await this.getCurrentLobby();
    if (lobby?.isOwner) {
      try {
        await fetch(`/api/lobby/${roomCode}/command`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            command: "start-game",
            initiator: localStorage.getItem("userId"),
            payload: { gameUrl },
            timestamp: Date.now()
          })
        });
      } catch (error) {}
    }
  }

  static setupCommandListener() {
    setInterval(async () => {
      try {
        const lobby = await this.getCurrentLobby();
        const command = lobby?.latest_command;
        if (command && command.timestamp !== this._lastProcessedCommand?.timestamp) {
          this._lastProcessedCommand = command;
          if (lobbyCommands[command.command]) {
            lobbyCommands[command.command](command.payload, this);
          }
        }
      } catch (err) {
        console.error("Erreur lors de l'exécution de la commande :", err);
      }
    }, 1000);
  }

  static automaticRedirect(url) {
    sessionStorage.setItem("isRedirecting", "true");
    window.location.href = url;
  }

  static async updatePlayers(lobby) {
    const players = await this.getActivePlayers();
    document.dispatchEvent(new CustomEvent("lobby-players-updated", { detail: players }));
  }
}

export { LobbyManager };

[f:\Github\DaGameThatIsFun\Files\Javascript\lobby_commands.js]
export const lobbyCommands = {
  "redirect": (payload, manager) => {
    if (!window.location.href.includes(payload.url)) {
      sessionStorage.setItem("isRedirecting", "true");
      window.location.href = payload.url;
    }
  },
  "start-countdown": (payload) => {
    document.dispatchEvent(new CustomEvent("start-countdown", { detail: payload }));
  },
  "cancel-countdown": () => {
    document.dispatchEvent(new Event("cancel-countdown"));
  },
  "lobby-deleted": (payload, manager) => {
    alert("Le salon a été supprimé par l'hôte !");
    localStorage.removeItem("roomCode");
    localStorage.removeItem("userId");
    if (manager) manager.stopPolling();
    window.location.href = "/";
  },
  "start-game": (payload, manager) => {
    // Logique pour démarrer le jeu
  }
};

[f:\Github\DaGameThatIsFun\Files\Javascript\index.js]
import { LobbyManager } from './lobby_manager.js';

document.addEventListener("DOMContentLoaded", async () => {
  LobbyManager.init();

  const playersContainer = document.getElementById("playersContainer");

  document.addEventListener("lobby-players-updated", (event) => {
    const players = event.detail;
    playersContainer.innerHTML = "";
    players.forEach(player => {
      const playerDiv = document.createElement("div");
      playerDiv.classList.add("player");
      playerDiv.innerHTML = `
        <img src="${player.avatar}" alt="${player.name}" class="player-avatar">
        <span class="player-name">${player.name}${player.isCurrentUser ? ' (Vous)' : ''}${player.isOwner ? ' 👑' : ''}</span>
      `;
      playersContainer.appendChild(playerDiv);
    });
  });

  const introScreen = document.getElementById("introScreen");
  setTimeout(() => {
    introScreen.classList.add("hidden");
    setTimeout(() => {
      introScreen.style.display = "none";
    }, 1000);
  }, 8000);

  const staticSound = document.getElementById("staticSound");
  const staticEffect = document.querySelector(".tv-static");
  const soundToggle = document.getElementById("soundToggle");
  let isMuted = true;
  const audio = new Audio("/static/music/draw-contest.mp3");
  audio.loop = true;

  function updateSoundIcon() {
    soundToggle.innerHTML = isMuted ? `
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
        <line x1="23" y1="9" x2="17" y2="15"></line>
        <line x1="17" y1="9" x2="23" y2="15"></line>
      </svg>` : `
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
        <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
        <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
      </svg>`;
  }

  soundToggle.addEventListener("click", () => {
    isMuted = !isMuted;
    if (isMuted) audio.pause();
    else audio.play().catch(console.error);
    updateSoundIcon();
  });

  updateSoundIcon();

  const games = {
    "draw-contest": {
      title: "Dessine moi un Désastre",
      description: "Une phrase loufoque, des dessins absurdes, et un vote pour élire l'œuvre la plus iconique. À vos pinceaux, le massacre commence ! \n4 à 8 Joueurs",
      preview: "/static/images/preview/draw-contest.png",
      music: "/static/music/draw-contest.mp3",
      playerNumber: "3-8"
    },
    "pictionary": {
      title: "Gribouilles & Embrouilles",
      description: "Montrez vos talents artistiques ! Un joueur dessine pendant que les autres se dépêchent de deviner le mot.",
      preview: "/static/images/preview/pictionary.png",
      music: "/static/music/pictionary.mp3",
      playerNumber: "3-8"
    },
    "quiz-rush": {
      title: "Quiz Rush",
      description: "Pensez vite ! Répondez à des questions originales dans ce quiz effréné.",
      preview: "/static/images/preview/quiz-rush.png",
      music: "/static/music/quiz-rush.mp3",
      playerNumber: "2-8"
    },
    "object-tales": {
      title: "La Quête Légendaire",
      description: "Devenez le maître du récit ! Inventez l'histoire la plus drôle ou intrigante à propos d'un objet étrange.",
      preview: "/static/images/preview/object-tales.png",
      music: "/static/music/object-tales.mp3",
      playerNumber: "4-8",
      disabled: true
    }
  };

  async function updatePreviewButtonState() {
    const previewButton = document.getElementById('previewButton');
    const roomCode = localStorage.getItem('roomCode');
    const activeGame = document.querySelector('.game-button.active')?.dataset.game;
    if (!roomCode || !activeGame) {
      previewButton.style.display = 'none';
      return;
    }
    try {
      const lobby = await LobbyManager.getCurrentLobby();
      const players = await LobbyManager.getActivePlayers();
      const gameInfo = games[activeGame];
      const minPlayers = parseInt(gameInfo.playerNumber.split('-')[0]);
      const isOwner = lobby?.isOwner;
      const hasEnoughPlayers = players.length >= minPlayers;
      const shouldShowButton = isOwner && roomCode;
      previewButton.style.display = shouldShowButton ? 'flex' : 'none';
      previewButton.disabled = !hasEnoughPlayers;
    } catch (error) {
      previewButton.style.display = 'none';
    }
  }

  setInterval(updatePreviewButtonState, 3000);

  function changeGamePreview(gameId) {
    const game = games[gameId];
    if (!game) return;
    staticEffect.classList.add("show-static");
    staticSound.currentTime = 0;
    staticSound.play();
    setTimeout(() => {
      document.getElementById("previewImage").src = game.preview;
      document.getElementById("previewTitle").textContent = game.title;
      document.getElementById("previewDescription").textContent = game.description;
      document.getElementById("previewPlayerNumber").textContent = game.playerNumber + " Joueurs";
      if (audio.src !== game.music) {
        audio.src = game.music;
        audio.load();
        if (!isMuted) audio.play().catch(console.error);
        updatePreviewButtonState();
      }
      staticEffect.classList.remove("show-static");
    }, 200);
  }

  document.querySelectorAll('.game-button').forEach(button => {
    button.addEventListener("click", () => {
      if (button.disabled) return;
      changeGamePreview(button.dataset.game);
      document.querySelectorAll('.game-button').forEach(btn => btn.classList.remove("active"));
      button.classList.add("active");
    });
  });

  const previewButton = document.querySelector('.preview-button');
  previewButton.addEventListener('click', () => {
    const activeGame = document.querySelector('.game-button.active')?.dataset.game;
    const roomCode = localStorage.getItem('roomCode');
    if (activeGame && roomCode) {
      const gameUrl = `/Games/loading/loading.html?game=${activeGame}&roomCode=${roomCode}`;
      LobbyManager.automaticRedirect(gameUrl);
    }
  });

  const currentRoomCode = localStorage.getItem("roomCode");
  if (currentRoomCode) {
    document.getElementById("playersContainer").style.display = "flex";
    const createLobbyLink = document.getElementById("createLobbyLink");
    const joinLobbyLink = document.getElementById("joinLobbyLink");
    const creditsLink = document.getElementById("creditsLink");
    const lobby = await LobbyManager.getCurrentLobby();
    const isOwner = lobby?.isOwner || false;

    if (createLobbyLink && joinLobbyLink && creditsLink) {
      createLobbyLink.innerHTML = `
        <button class="action-button quit-lobby">
          <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M16 17l5-5-5-5"/>
            <line x1="21" y1="12" x2="9" y2="12"/>
          </svg>
          Quitter
        </button>`;
      joinLobbyLink.innerHTML = `
        <button class="action-button add-players" ${!isOwner ? 'disabled' : ''}>
          <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="12" y1="5" x2="12" y2="19"/>
            <line x1="5" y1="12" x2="19" y2="12"/>
          </svg>
          Ajouter Joueurs
        </button>`;
      creditsLink.innerHTML = `
        <button class="action-button credits">
          <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="8" r="7"></circle>
            <polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>
          </svg>
          Credits
        </button>`;

      createLobbyLink.querySelector('button').addEventListener('click', async () => {
        if (confirm("Êtes-vous sûr de vouloir quitter le lobby ?")) {
          await LobbyManager.leaveLobby();
          window.location.reload();
        }
      });

      joinLobbyLink.querySelector('button').addEventListener('click', () => {
        LobbyManager.automaticRedirect('waiting_room.html');
      });

      creditsLink.querySelector('button').addEventListener('click', () => {
        LobbyManager.automaticRedirect('credits.html');
      });
    }
  }
});

window.addEventListener('beforeunload', async () => {
  if (!sessionStorage.getItem('isRedirecting')) {
    const lobby = await LobbyManager.getCurrentLobby();
    if (lobby?.isOwner) {
      await LobbyManager.leaveLobby();
    }
  }
});

async function loadBottomButtons() {
  try {
    const response = await fetch('button_config.json');
    const config = await response.json();
    const bottomActions = document.getElementById('bottomActions');

    if (!bottomActions) {
      console.error("L'élément 'bottomActions' est introuvable dans le DOM.");
      return;
    }

    const inLobby = localStorage.getItem('roomCode') ? true : false;
    const buttons = inLobby ? config.inLobby : config.outLobby;
    bottomActions.innerHTML = '';

    buttons.forEach(btn => {
      const a = document.createElement('a');
      if (btn.link) {
        a.href = btn.link;
      }
      const button = document.createElement('button');
      button.className = 'action-button';
      if (btn.action) button.classList.add(btn.action);
      button.innerHTML = btn.icon + btn.title;

      button.addEventListener('click', async (e) => {
        e.preventDefault();
        if (inLobby) {
          if (btn.action === 'quit') {
            if (confirm("Êtes-vous sûr de vouloir quitter le lobby ?")) {
              await LobbyManager.leaveLobby();
              localStorage.removeItem('roomCode');
              window.location.href = 'index.html';
            }
          } else if (btn.action === 'credits') {
            const lobby = await LobbyManager.getCurrentLobby();
            if (lobby && lobby.isOwner) {
              await LobbyManager.sendCommandToPlayers('redirect', { url: `credits.html?roomCode=${localStorage.getItem('roomCode')}` });
              window.location.href = `credits.html?roomCode=${localStorage.getItem('roomCode')}`;
            } else {
              LobbyManager.automaticRedirect(`credits.html?roomCode=${localStorage.getItem('roomCode')}`);
            }
          } else if (btn.action === 'waiting') {
            await LobbyManager.sendCommandToPlayers('redirect', { url: `waiting_room.html?roomCode=${localStorage.getItem('roomCode')}` });
            window.location.href = `waiting_room.html?roomCode=${localStorage.getItem('roomCode')}`;
          } else if (btn.link) {
            window.location.href = btn.link;
          }
        } else {
          if (btn.link) {
            window.location.href = btn.link;
          }
        }
      });

      a.appendChild(button);
      bottomActions.appendChild(a);
    });
  } catch (error) {
    console.error("[INDEX] Erreur lors du chargement des boutons:", error);
  }
}

document.addEventListener("DOMContentLoaded", function() {
  if (localStorage.getItem('introSeen')) {
    document.getElementById('introScreen').style.display = 'none';
  } else {
    localStorage.setItem('introSeen', 'true');
  }
  loadBottomButtons();
});

