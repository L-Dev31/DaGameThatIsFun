Refait et oversimplifie entieremetn la logique de sorte qu'on ait une fonction qui envoie une commande javascript automatiquement et en meme temps a tout le monde dans le lobby yy compris celui qui l'a send (l'owner generalement) genre ça doit etre un truc du genre SendCommand('script js'); quoi qu'il arrive meme avec un gros retards tout les joueurs doivent l'avoir reçu et executé a 100%

Server.py:

lobby_redirection.js:

import LobbyManager from './lobby_manager.js';

function setupCommandListener() {
  let lastCommandTime = 0;

  setInterval(async () => {
    try {
      const lobby = await LobbyManager.getCurrentLobby();
      const command = lobby?.latest_command;

      if (command && command.timestamp > lastCommandTime) {
        lastCommandTime = command.timestamp;

        console.log("[LOBBY_REDIRECTION] Commande reçue :", command);
        switch (command.command) {
          case 'redirect':
            if (shouldRedirect(command.payload.url)) { 
              console.log(Redirection vers ${command.payload.url});
              window.location.href = command.payload.url;
            }
            break;
          case 'lobby-deleted':
            console.log("Nettoyage du lobby...");
            localStorage.removeItem('roomCode');
            localStorage.removeItem('userId');
            LobbyManager.stopPolling();
            window.location.href = 'index.html';
            break;
        }
      }
    } catch (err) {
      console.error("Erreur de traitement :", err);
    }
  }, 1000);
}

export function automaticRedirect(url) {
  if (shouldRedirect(url)) {
    window.location.href = url;
  }
}

export function shouldRedirect(targetUrl) {
  const currentPath = window.location.pathname.split('/').pop();
  const targetPath = new URL(targetUrl, window.location.href).pathname.split('/').pop();
  return currentPath !== targetPath;
}

setupCommandListener();

lobby_manager.js:

waiting_room.js (la ou c'est sensé nottament être utilisé a la fin du timer):