I need you to enhance the current lobby management in my java/python project.
Key requirements:
1. The commands are sent to all players in the current Lobby, and even when there is a delay they must be received and executed
2. The players displaying must be implemented in the lobby manager js
3. Allow to use different cases system in the sendCommand function so with only one line of code we can do everything we need in any scenarios
Please consider:
- Error handling
- Edge cases
- Performance optimization
- Best practices for [language/framework]
Please do not unnecessarily remove any comments or code.
Generate the code with little but clear comments explaining the logic.
Make so the maximum is centralized in the least amount of files in order to only have to import one thing in order to get everything needed.
Give the entirety of each files 




server.py:

import http.server
import socketserver
import ujson as json
import threading
import time
from System.models import LobbySession
from System.lobby import active_sessions, create_lobby, join_lobby, leave_lobby
from System.qr import get_local_ip, generate_qr_code

active_sessions_lock = threading.Lock()
PORT = 8080
DIRECTORY = "Files"

class LobbyHandler(http.server.SimpleHTTPRequestHandler):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, directory=DIRECTORY, **kwargs)

    def end_headers(self):
        if self.path.startswith('/api'):
            self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')
        else:
            self.send_header('Cache-Control', 'max-age=3600')
        super().end_headers()

    def send_json_response(self, data, status=200):
        self.send_response(status)
        self.send_header('Content-type', 'application/json')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.end_headers()
        self.wfile.write(json.dumps(data).encode())

    def send_error_response(self, message, status=400):
        self.send_json_response({'error': message, 'success': False}, status)

    def do_OPTIONS(self):
        self.send_response(200)
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, DELETE, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        self.end_headers()

    def do_POST(self):
        content_length = int(self.headers.get('Content-Length', 0))
        post_data = {}
        if content_length > 0:
            post_data = json.loads(self.rfile.read(content_length).decode('utf-8'))
        client_ip = self.client_address[0]
        try:
            if self.path == '/api/lobby/create':
                response = create_lobby(
                    post_data.get('playerName'),
                    post_data.get('password'),
                    post_data.get('avatarIndex', 0),
                    post_data.get('maxPlayers', 8),
                    client_ip
                )
                self.send_json_response(response)

            elif self.path == '/api/lobby/join':
                response = join_lobby(
                    post_data.get('roomCode'),
                    post_data.get('playerName'),
                    post_data.get('password'),
                    post_data.get('avatarIndex', 0),
                    client_ip
                )
                self.send_json_response(response)

            elif self.path.startswith('/api/lobby/') and self.path.endswith('/leave'):
                room_code = self.path.split('/')[-2]
                response = leave_lobby(post_data.get('userId'), room_code)
                self.send_json_response(response)

            elif self.path.startswith('/api/lobby/') and self.path.endswith('/command'):
                room_code = self.path.split('/')[-2]
                with active_sessions_lock:
                    if room_code not in active_sessions:
                        raise ValueError("Salon introuvable")
                    lobby = active_sessions[room_code]
                    if post_data.get('initiator') != lobby.owner:
                        self.send_error_response("Action non autoris√©e", 403)
                        return

                    command = post_data.get('command')
                    if command == 'start-game':
                        lobby.latest_command = {
                            'command': 'redirect',
                            'payload': {
                                'url': post_data.get('payload').get('gameUrl'),
                                'force': True
                            },
                            'timestamp': time.time(),
                            'initiator': lobby.owner
                        }
                    else:
                        # Mise √† jour du status du lobby si un nouveau status est fourni (ex : waiting)
                        if command == 'redirect' and post_data.get('payload') and post_data.get('payload').get('newState'):
                            lobby.state = post_data.get('payload').get('newState')
                        lobby.latest_command = {
                            'command': command,
                            'payload': post_data.get('payload'),
                            'timestamp': time.time(),
                            'initiator': lobby.owner
                        }
                self.send_json_response({'success': True})

            else:
                self.send_error_response("Endpoint non trouv√©", 404)
        except Exception as e:
            self.send_error_response(str(e))

    def do_GET(self):
        try:
            base_path = self.path.split('?')[0]
            if base_path == '/get_ip':
                ip = get_local_ip()
                qr_code = generate_qr_code(ip, PORT)
                self.send_json_response({
                    "url": f"http://{ip}:{PORT}",
                    "qr_code": qr_code
                })
            elif base_path == '/api/lobbies':
                lobbies_data = []
                with active_sessions_lock:
                    for session in active_sessions.values():
                        lobby_data = session.to_dict()
                        lobby_data['latest_command'] = getattr(session, 'latest_command', None)
                        lobbies_data.append(lobby_data)
                self.send_json_response({'lobbies': lobbies_data})
            elif base_path.startswith('/api/lobby/') and len(base_path.split('/')) == 4:
                room_code = base_path.split('/')[-1]
                with active_sessions_lock:
                    if room_code in active_sessions:
                        lobby = active_sessions[room_code]
                        lobby_data = lobby.to_dict()
                        lobby_data['latest_command'] = getattr(lobby, 'latest_command', None)
                        self.send_json_response(lobby_data)
                    else:
                        self.send_error_response("Salon non trouv√©", 404)
            else:
                super().do_GET()
        except Exception as e:
            self.send_error_response(str(e))

    def do_DELETE(self):
        if self.path.startswith('/api/lobby/delete/'):
            room_code = self.path.split('/')[-1]
            with active_sessions_lock:
                if room_code in active_sessions:
                    del active_sessions[room_code]
                    self.send_json_response({'success': True})
                else:
                    self.send_error_response("Le salon n'existe pas", 404)
        else:
            self.send_error_response("Endpoint non trouv√©", 404)

def run_server():
    with socketserver.ThreadingTCPServer(("", PORT), LobbyHandler) as httpd:
        httpd.serve_forever()

if __name__ == "__main__":
    run_server()


lobby.py:

import random
import string
import time
import threading
from typing import Dict, Optional
from System.models import LobbySession, User

active_sessions: Dict[str, LobbySession] = {}
active_sessions_lock = threading.Lock()

def generate_code() -> str:
    while True:
        code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=4))
        with active_sessions_lock:
            if code not in active_sessions:
                return code

def create_lobby(player_name: str, password: Optional[str], avatar_index: int, max_players: int, client_ip: str) -> dict:
    if not player_name:
        raise ValueError("Le nom du joueur est requis")
    if max_players not in range(2, 9):
        raise ValueError("Le nombre de joueurs doit √™tre entre 2 et 8")

    room_code = generate_code()
    user_id = str(random.randint(10000, 99999))

    owner = User(
        id=user_id,
        name=player_name,
        avatar_index=avatar_index,
        join_time=time.time(),
        ip_address=client_ip
    )

    lobby_session = LobbySession(
        code=room_code,
        name=f"Salon de {player_name}",
        owner=user_id,
        password=password,
        users={user_id: owner},
        created_at=time.time(),
        max_players=max_players
    )

    with active_sessions_lock:
        active_sessions[room_code] = lobby_session

    return {
        'success': True,
        'roomCode': room_code,
        'userId': user_id,
        'sessionData': lobby_session.to_dict()
    }

def join_lobby(room_code: str, player_name: str, password: Optional[str], avatar_index: int, client_ip: str) -> dict:
    if not room_code or not player_name:
        raise ValueError("Le code du salon et le nom du joueur sont requis")

    with active_sessions_lock:
        if room_code not in active_sessions:
            raise ValueError("Le salon n'existe pas")
        lobby = active_sessions[room_code]

    with lobby.lock:
        if lobby.password and lobby.password != password:
            raise ValueError("Mot de passe incorrect")
        if len(lobby.users) >= lobby.max_players:
            raise ValueError("Le salon est plein")

        user_id = str(random.randint(10000, 99999))
        new_user = User(
            id=user_id,
            name=player_name,
            avatar_index=avatar_index,
            join_time=time.time(),
            ip_address=client_ip
        )

        lobby.users[user_id] = new_user

    return {
        'success': True,
        'userId': user_id,
        'sessionData': lobby.to_dict()
    }

def leave_lobby(user_id: str, room_code: str) -> dict:
    if room_code not in active_sessions:
        return {'success': False, 'error': 'Le salon n\'existe pas'}
    
    lobby = active_sessions[room_code]

    if user_id in lobby.users:
        del lobby.users[user_id]

    if user_id == lobby.owner:
        # Si l'owner quitte, le lobby est supprim√© enti√®rement
        print(f"L'owner du lobby {room_code} a quitt√©, suppression du lobby.")
        del active_sessions[room_code]
    elif not lobby.users:
        print(f"Le lobby {room_code} est vide et sera supprim√©.")
        del active_sessions[room_code]

    return {'success': True}


Lobby_manager.js:

class LobbyManager {
  static POLL_INTERVAL = 1000;
  static MAX_POLL_INTERVAL = 30000;
  static POLL_BACKOFF_FACTOR = 1.5;
  static _currentPollInterval = this.POLL_INTERVAL;
  static _pollTimeout = null;
  static _listeners = new Set();
  static _errorCount = 0;
  static _MAX_ERRORS = 5;

  static init() {
    console.log("[LOBBY_MANAGER] Initialisation...");
    if (localStorage.getItem('roomCode')) {
      this.startPolling();
    }
    this._setupUnloadListener();
  }

  static _setupUnloadListener() {
    window.addEventListener('beforeunload', (event) => {
      const isRedirecting = sessionStorage.getItem('isRedirecting');
      const roomCode = localStorage.getItem('roomCode');
      const userId = localStorage.getItem('userId');
      
      if (!isRedirecting && roomCode && userId) {
        const data = { userId };
        const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
        navigator.sendBeacon(`/api/lobby/${roomCode}/leave`, blob);
        console.log("[LOBBY_MANAGER] Envoi de la requ√™te de sortie via Beacon.");
      }
      sessionStorage.removeItem('isRedirecting'); // Nettoyage
    });
  }

  static async getActivePlayers() {
      console.log("[LOBBY_MANAGER] R√©cup√©ration des joueurs actifs...");
      const userId = localStorage.getItem('userId');
      const lobby = await this.getCurrentLobby();
      if (lobby) {
          return Object.values(lobby.users)
              .sort((a, b) => a.join_time - b.join_time)
              .map((user) => ({
                  id: user.id,
                  name: user.name,
                  avatar: `/static/images/avatar/${user.avatar_index + 1}.png`,
                  isOwner: user.id === lobby.owner,
                  isCurrentUser: user.id === userId
              }));
      }
      return [];
  }

  static startPolling() {
    if (this._pollTimeout !== null) return;
    console.log("[LOBBY_MANAGER] D√©but du polling du lobby.");
    this._pollLobby();
  }

  static stopPolling() {
    if (this._pollTimeout) {
      clearTimeout(this._pollTimeout);
      this._pollTimeout = null;
      console.log("[LOBBY_MANAGER] Polling arr√™t√©.");
    }
  }

  static addListener(callback) {
    this._listeners.add(callback);
    return () => this._listeners.delete(callback);
  }

  static async _pollLobby() {
    try {
      const lobby = await this.getCurrentLobby();
      if (lobby) {
        this._errorCount = 0;
        this._currentPollInterval = this.POLL_INTERVAL;
        this._notifyListeners(lobby);
      } else {
        console.error("[LOBBY_MANAGER] Lobby introuvable, arr√™t du polling.");
        this.stopPolling();
        return;
      }
    } catch (error) {
      this._errorCount++;
      console.error(`[LOBBY_MANAGER] Erreur lors du polling (${this._errorCount}/${this._MAX_ERRORS}):`, error);
      if (this._errorCount >= this._MAX_ERRORS) {
        console.error("[LOBBY_MANAGER] Nombre maximum d'erreurs atteint. Arr√™t du polling.");
        this.stopPolling();
        return;
      }
      this._currentPollInterval = Math.min(
        this._currentPollInterval * this.POLL_BACKOFF_FACTOR,
        this.MAX_POLL_INTERVAL
      );
    } finally {
      if (this._pollTimeout !== null) {
        this._pollTimeout = setTimeout(() => this._pollLobby(), this._currentPollInterval);
      }
    }
  }

  static _notifyListeners(lobby) {
    for (const listener of this._listeners) {
      listener(lobby);
    }
  }

  static async getCurrentLobby() {
    const roomCode = localStorage.getItem('roomCode');
    const userId = localStorage.getItem('userId');
    if (!roomCode || !userId) return null;
    try {
      const response = await fetch(`/api/lobby/${roomCode}`);
      if (!response.ok) {
        if (response.status === 404) {
          console.error("[LOBBY_MANAGER] Lobby non trouv√© (404). Nettoyage des donn√©es locales.");
          localStorage.removeItem('roomCode');
          localStorage.removeItem('userId');
          this.stopPolling();
        }
        return null;
      }
      const data = await response.json();
      console.log("[LOBBY_MANAGER] Lobby r√©cup√©r√© :", data);
      return {
        ...data,
        isOwner: data.owner === userId,
        currentUser: data.users[userId]
      };
    } catch (error) {
      console.error("[LOBBY_MANAGER] Erreur lors du fetch du lobby:", error);
      return null;
    }
  }

  static async isCurrentUserOwner() {
    const lobby = await this.getCurrentLobby();
    return lobby?.isOwner || false;
  }

  static async leaveLobby() {
    const roomCode = localStorage.getItem('roomCode');
    const userId = localStorage.getItem('userId');
    if (roomCode && userId) {
      try {
        console.log("[LOBBY_MANAGER] Envoi de la requ√™te pour quitter le lobby.");
        await fetch(`/api/lobby/${roomCode}/leave`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userId })
        });
      } catch (error) {
        console.error("[LOBBY_MANAGER] Erreur lors de la demande de sortie du lobby:", error);
      }
    }
    localStorage.removeItem('roomCode');
    localStorage.removeItem('userId');
    this.stopPolling();
  }

  static async sendCommandToPlayers(command, payload = {}) {
    const roomCode = localStorage.getItem('roomCode');
    const lobby = await this.getCurrentLobby();
    
    if (lobby?.isOwner) {  
        try {
            console.log(`[LOBBY_MANAGER] Envoi de la commande '${command}' avec payload:`, payload);
            await fetch(`/api/lobby/${roomCode}/command`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    command,
                    initiator: localStorage.getItem('userId'),
                    payload,
                    timestamp: Date.now()
                })
            });
            console.log(`[LOBBY_MANAGER] Commande '${command}' envoy√©e avec succ√®s.`);
        } catch (error) {
            console.error("[LOBBY_MANAGER] Erreur lors de l'envoi de la commande:", error);
        }
    } else {
        console.warn("[LOBBY_MANAGER] Seul l'owner peut envoyer des commandes.");
    }
  }

  static async getActivePlayers() {
    const userId = localStorage.getItem('userId');
    const lobby = await this.getCurrentLobby();
    if (lobby) {
        return Object.values(lobby.users)
            .sort((a, b) => a.join_time - b.join_time)
            .map((user) => ({
                id: user.id,
                name: user.name,
                avatar: `/static/images/avatar/${user.avatar_index + 1}.png`,
                isOwner: user.id === lobby.owner,
                isCurrentUser: user.id === userId
            }));
    }
    return [];
}

  static async startGame(gameUrl) {
    const roomCode = localStorage.getItem('roomCode');
    const lobby = await this.getCurrentLobby();
    if (lobby?.isOwner) {
      try {
        console.log("[LOBBY_MANAGER] Lancement de la partie avec l'URL:", gameUrl);
        await fetch(`/api/lobby/${roomCode}/command`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            command: 'start-game',
            initiator: localStorage.getItem('userId'),
            payload: { gameUrl },
            timestamp: Date.now()
          })
        });
      } catch (error) {
        console.error("[LOBBY_MANAGER] Erreur lors du lancement de la partie:", error);
      }
    }
  }
}

export default LobbyManager;


Lobby_redirection.js:

import LobbyManager from './lobby_manager.js';

function setupCommandListener() {
  let lastCommandTime = 0;

  setInterval(async () => {
    try {
      const lobby = await LobbyManager.getCurrentLobby();
      const command = lobby?.latest_command;
      
      if (command && command.timestamp > lastCommandTime) {
        lastCommandTime = command.timestamp;
        
        console.log("[LOBBY_REDIRECTION] Commande re√ßue :", command);
        switch (command.command) {
          case 'redirect':
            if (shouldRedirect(command.payload.url)) { 
              console.log(`Redirection vers ${command.payload.url}`);
              window.location.href = command.payload.url;
            }
            break;
          case 'lobby-deleted':
            console.log("Nettoyage du lobby...");
            localStorage.removeItem('roomCode');
            localStorage.removeItem('userId');
            LobbyManager.stopPolling();
            window.location.href = 'index.html';
            break;
        }
      }
    } catch (err) {
      console.error("Erreur de traitement :", err);
    }
  }, 1000);
}

export function automaticRedirect(url) {
  if (shouldRedirect(url)) {
    window.location.href = url;
  }
}

export function shouldRedirect(targetUrl) {
  const currentPath = window.location.pathname.split('/').pop();
  const targetPath = new URL(targetUrl, window.location.href).pathname.split('/').pop();
  return currentPath !== targetPath;
}

setupCommandListener();



index.js (where it is used):

// index.js - Script principal pour la page d'accueil / s√©lection de jeu

import LobbyManager from './lobby_manager.js';
import { automaticRedirect } from './lobby_redirection.js';

document.addEventListener("DOMContentLoaded", async () => {
  const playersContainer = document.getElementById("playersContainer");

  async function updatePlayers() {
    const players = await LobbyManager.getActivePlayers();
    if (players.length === 0 && localStorage.getItem('roomCode')) {
      localStorage.removeItem('roomCode');
      localStorage.removeItem('userId');
      window.location.reload();
      return;
    }
    playersContainer.innerHTML = "";
    players.forEach(player => {
      const playerDiv = document.createElement("div");
      playerDiv.classList.add("player");
      playerDiv.innerHTML = `
        <img src="${player.avatar}" alt="${player.name}" class="player-avatar">
        <span class="player-name">${player.name}${player.isCurrentUser ? ' (Vous)' : ''}${player.isOwner ? ' üëë' : ''}</span>
      `;
      playersContainer.appendChild(playerDiv);
    });
    await updatePreviewButtonState();
  }

  await updatePlayers();
  setInterval(updatePlayers, 5000);

  const introScreen = document.getElementById("introScreen");
  setTimeout(() => {
    introScreen.classList.add("hidden");
    setTimeout(() => {
      introScreen.style.display = "none";
    }, 1000);
  }, 8000);

  const staticSound = document.getElementById("staticSound");
  const staticEffect = document.querySelector(".tv-static");
  const soundToggle = document.getElementById("soundToggle");
  let isMuted = true;
  const audio = new Audio("/static/music/draw-contest.mp3");
  audio.loop = true;

  function updateSoundIcon() {
    soundToggle.innerHTML = isMuted ? `
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
        <line x1="23" y1="9" x2="17" y2="15"></line>
        <line x1="17" y1="9" x2="23" y2="15"></line>
      </svg>` : `
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
        <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
        <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
      </svg>`;
  }

  soundToggle.addEventListener("click", () => {
    isMuted = !isMuted;
    if (isMuted) audio.pause();
    else audio.play().catch(console.error);
    updateSoundIcon();
  });
  updateSoundIcon();

  const games = {
    "draw-contest": {
      title: "Dessine moi un D√©sastre",
      description: "Une phrase loufoque, des dessins absurdes, et un vote pour √©lire l'≈ìuvre la plus iconique. √Ä vos pinceaux, le massacre commence ! \n4 √† 8 Joueurs",
      preview: "/static/images/preview/draw-contest.png",
      music: "/static/music/draw-contest.mp3",
      playerNumber: "3-8"
    },
    "pictionary": {
      title: "Gribouilles & Embrouilles",
      description: "Montrez vos talents artistiques ! Un joueur dessine pendant que les autres se d√©p√™chent de deviner le mot.",
      preview: "/static/images/preview/pictionary.png",
      music: "/static/music/pictionary.mp3",
      playerNumber: "3-8"
    },
    "quiz-rush": {
      title: "Quiz Rush",
      description: "Pensez vite ! R√©pondez √† des questions originales dans ce quiz effr√©n√©.",
      preview: "/static/images/preview/quiz-rush.png",
      music: "/static/music/quiz-rush.mp3",
      playerNumber: "2-8"
    },
    "object-tales": {
      title: "La Qu√™te L√©gendaire",
      description: "Devenez le ma√Ætre du r√©cit ! Inventez l'histoire la plus dr√¥le ou intrigante √† propos d'un objet √©trange.",
      preview: "/static/images/preview/object-tales.png",
      music: "/static/music/object-tales.mp3",
      playerNumber: "4-8",
      disabled: true
    }
  };

  async function updatePreviewButtonState() {
    const previewButton = document.getElementById('previewButton');
    const roomCode = localStorage.getItem('roomCode');
    const activeGame = document.querySelector('.game-button.active')?.dataset.game;
    
    if (!roomCode || !activeGame) {
      previewButton.style.display = 'none';
      return;
    }
  
    try {
      const lobby = await LobbyManager.getCurrentLobby();
      const players = await LobbyManager.getActivePlayers();
      const gameInfo = games[activeGame];
      
      // Extraire le nombre minimum de joueurs
      const minPlayers = parseInt(gameInfo.playerNumber.split('-')[0]);
      const isOwner = lobby?.isOwner;
      
      // V√©rifier les conditions
      const hasEnoughPlayers = players.length >= minPlayers;
      const shouldShowButton = isOwner && roomCode;
  
      previewButton.style.display = shouldShowButton ? 'flex' : 'none';
      previewButton.disabled = !hasEnoughPlayers;
  
    } catch (error) {
      console.error('Error updating button state:', error);
      previewButton.style.display = 'none';
    }
  }

  setInterval(updatePreviewButtonState, 3000);

  function changeGamePreview(gameId) {
    const game = games[gameId];
    if (!game) return;
    staticEffect.classList.add("show-static");
    staticSound.currentTime = 0;
    staticSound.play();
    setTimeout(() => {
      document.getElementById("previewImage").src = game.preview;
      document.getElementById("previewTitle").textContent = game.title;
      document.getElementById("previewDescription").textContent = game.description;
      document.getElementById("previewPlayerNumber").textContent = game.playerNumber + " Joueurs";
      if (audio.src !== game.music) {
        audio.src = game.music;
        audio.load();
        if (!isMuted) audio.play().catch(console.error);
        updatePreviewButtonState();
      }
      staticEffect.classList.remove("show-static");
    }, 200);
  }

  document.querySelectorAll('.game-button').forEach(button => {
    button.addEventListener("click", () => {
      if (button.disabled) return;
      changeGamePreview(button.dataset.game);
      document.querySelectorAll('.game-button').forEach(btn => btn.classList.remove("active"));
      button.classList.add("active");
    });
  });

  const previewButton = document.querySelector('.preview-button');
    previewButton.addEventListener('click', () => {
    const activeGame = document.querySelector('.game-button.active')?.dataset.game;
    const roomCode = localStorage.getItem('roomCode');
    
    if (activeGame && roomCode) {
      const gameUrl = `/Games/loading/loading.html?game=${activeGame}&roomCode=${roomCode}`;
      automaticRedirect(gameUrl);
    }
  });

  const roomCode = localStorage.getItem("roomCode");
  if (roomCode) {
    document.getElementById("playersContainer").style.display = "flex";
    const createLobbyLink = document.getElementById("createLobbyLink");
    const joinLobbyLink = document.getElementById("joinLobbyLink");
    const creditsLink = document.getElementById("creditsLink");

    const lobby = await LobbyManager.getCurrentLobby();
    const isOwner = lobby?.isOwner || false;

    createLobbyLink.innerHTML = `
      <button class="action-button quit-lobby">
        <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M16 17l5-5-5-5"/>
          <line x1="21" y1="12" x2="9" y2="12"/>
        </svg>
        Quitter
      </button>`;
    joinLobbyLink.innerHTML = `
      <button class="action-button add-players" ${!isOwner ? 'disabled' : ''}>
        <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="12" y1="5" x2="12" y2="19"/>
          <line x1="5" y1="12" x2="19" y2="12"/>
        </svg>
        Ajouter Joueurs
      </button>`;
    creditsLink.innerHTML = `
      <button class="action-button credits">
        <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="8" r="7"></circle>
          <polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>
        </svg>
        Credits
      </button>`;

    createLobbyLink.querySelector('button').addEventListener('click', async () => {
      if (confirm("√ätes-vous s√ªr de vouloir quitter le lobby ?")) {
        await LobbyManager.leaveLobby();
        window.location.reload();
      }
    });

    joinLobbyLink.querySelector('button').addEventListener('click', () => {
      automaticRedirect('waiting_room.html');
    });

    creditsLink.querySelector('button').addEventListener('click', () => {
      automaticRedirect('credits.html');
    });
  }

  if (roomCode) LobbyManager.startPolling();
});

const roomCode = localStorage.getItem('roomCode');

window.addEventListener('beforeunload', async () => {
  const lobby = await LobbyManager.getCurrentLobby();
  if (lobby?.isOwner) {
    console.log("[INDEX] Owner quitte la page, nettoyage du lobby");
    await LobbyManager.leaveLobby();
  }
});

if (!roomCode) {
  localStorage.removeItem('roomCode');
  localStorage.removeItem('userId');
  LobbyManager.stopPolling();
} else {
  LobbyManager.init();
}

async function loadBottomButtons() {
  try {
    const response = await fetch('button_config.json');
    const config = await response.json();
    const bottomActions = document.getElementById('bottomActions');
    const inLobby = localStorage.getItem('roomCode') ? true : false;
    console.log(`[INDEX] Mode ${inLobby ? "EN LOBBY" : "HORS LOBBY"} ‚Äì chargement de la configuration des boutons.`);
    const buttons = inLobby ? config.inLobby : config.outLobby;
    bottomActions.innerHTML = '';
    buttons.forEach(btn => {
      const a = document.createElement('a');
      if (btn.link) {
        a.href = btn.link;
      }
      const button = document.createElement('button');
      button.className = 'action-button';
      if (btn.action) button.classList.add(btn.action);
      button.innerHTML = btn.icon + btn.title;
      button.addEventListener('click', async (e) => {
        e.preventDefault();
        console.log(`[INDEX] Bouton cliqu√©: ${btn.title}`);
        if (inLobby) {
          if (btn.action === 'quit') {
            if (confirm("√ätes-vous s√ªr de vouloir quitter le lobby ?")) {
              console.log("[INDEX] Quitter le lobby demand√©.");
              await LobbyManager.leaveLobby();
              localStorage.removeItem('roomCode');
              window.location.href = 'index.html';
            }
          } else if (btn.action === 'credits') {
            const lobby = await LobbyManager.getCurrentLobby();
            if (lobby && lobby.isOwner) {
              console.log("[INDEX] Owner quittant le lobby pour acc√©der aux Credits.");
              await LobbyManager.sendCommandToPlayers('redirect', { url: `credits.html?roomCode=${roomCode}` });
              window.location.href = `credits.html?roomCode=${roomCode}`;
            } else {
              console.log("[INDEX] Redirection automatique vers Credits pour non-owner.");
              automaticRedirect(`credits.html?roomCode=${roomCode}`);
            }
          } else if (btn.action === 'waiting') {
            console.log("[INDEX] Owner envoie une commande pour que tout le monde aille en salle d'attente.");
            await LobbyManager.sendCommandToPlayers('redirect', { url: `waiting_room.html?roomCode=${roomCode}` });
            window.location.href = `waiting_room.html?roomCode=${roomCode}`;
          } else if (btn.link) {
            console.log(`[INDEX] Redirection vers ${btn.link}`);
            window.location.href = btn.link;
          }
        } else {
          if (btn.link) {
            console.log(`[INDEX] Redirection vers ${btn.link} (mode hors lobby)`);
            window.location.href = btn.link;
          }
        }
      });
      a.appendChild(button);
      bottomActions.appendChild(a);
    });
  } catch (error) {
    console.error("[INDEX] Erreur lors du chargement des boutons:", error);
  }
}

// V√©rifie si l'intro a d√©j√† √©t√© vue
document.addEventListener("DOMContentLoaded", function() {
  if (localStorage.getItem('introSeen')) {
    document.getElementById('introScreen').style.display = 'none';
  } else {
    localStorage.setItem('introSeen', 'true');
  }
});

loadBottomButtons();