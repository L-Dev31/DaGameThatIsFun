I need you to enhance the current lobby management in my java/python project.
Key requirements:
1. The commands are sent to all players in the current Lobby, and even when there is a delay they must be received and executed
2. The players displaying must be implemented in the lobby manager js
3. Allow to use different cases system in the sendCommand function so with only one line of code we can do everything we need in any scenarios
Please consider:
- Error handling
- Edge cases
- Performance optimization
- Best practices for [language/framework]
Please do not unnecessarily remove any comments or code.
Generate the code with little but clear comments explaining the logic.
Make so the maximum is centralized in the least amount of files in order to only have to import one thing in order to get everything needed.
Give the entirety of each files 




server.py:

import http.server
import socketserver
import ujson as json
import threading
import time
from System.models import LobbySession
from System.lobby import active_sessions, create_lobby, join_lobby, leave_lobby
from System.qr import get_local_ip, generate_qr_code

active_sessions_lock = threading.Lock()
PORT = 8080
DIRECTORY = "Files"

class LobbyHandler(http.server.SimpleHTTPRequestHandler):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, directory=DIRECTORY, **kwargs)

    def end_headers(self):
        if self.path.startswith('/api'):
            self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')
        else:
            self.send_header('Cache-Control', 'max-age=3600')
        super().end_headers()

    def send_json_response(self, data, status=200):
        self.send_response(status)
        self.send_header('Content-type', 'application/json')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.end_headers()
        self.wfile.write(json.dumps(data).encode())

    def send_error_response(self, message, status=400):
        self.send_json_response({'error': message, 'success': False}, status)

    def do_OPTIONS(self):
        self.send_response(200)
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Access-Control-Allow-Methods', 'GET, POST, DELETE, OPTIONS')
        self.send_header('Access-Control-Allow-Headers', 'Content-Type')
        self.end_headers()

    def do_POST(self):
        content_length = int(self.headers.get('Content-Length', 0))
        post_data = {}
        if content_length > 0:
            post_data = json.loads(self.rfile.read(content_length).decode('utf-8'))
        client_ip = self.client_address[0]
        try:
            if self.path == '/api/lobby/create':
                response = create_lobby(
                    post_data.get('playerName'),
                    post_data.get('password'),
                    post_data.get('avatarIndex', 0),
                    post_data.get('maxPlayers', 8),
                    client_ip
                )
                self.send_json_response(response)

            elif self.path == '/api/lobby/join':
                response = join_lobby(
                    post_data.get('roomCode'),
                    post_data.get('playerName'),
                    post_data.get('password'),
                    post_data.get('avatarIndex', 0),
                    client_ip
                )
                self.send_json_response(response)

            elif self.path.startswith('/api/lobby/') and self.path.endswith('/leave'):
                room_code = self.path.split('/')[-2]
                response = leave_lobby(post_data.get('userId'), room_code)
                self.send_json_response(response)

            elif self.path.startswith('/api/lobby/') and self.path.endswith('/command'):
                room_code = self.path.split('/')[-2]
                with active_sessions_lock:
                    if room_code not in active_sessions:
                        raise ValueError("Salon introuvable")
                    lobby = active_sessions[room_code]
                    if post_data.get('initiator') != lobby.owner:
                        self.send_error_response("Action non autorisée", 403)
                        return

                    command = post_data.get('command')
                    if command == 'start-game':
                        lobby.latest_command = {
                            'command': 'redirect',
                            'payload': {
                                'url': post_data.get('payload').get('gameUrl'),
                                'force': True
                            },
                            'timestamp': time.time(),
                            'initiator': lobby.owner
                        }
                    else:
                        # Mise à jour du status du lobby si un nouveau status est fourni (ex : waiting)
                        if command == 'redirect' and post_data.get('payload') and post_data.get('payload').get('newState'):
                            lobby.state = post_data.get('payload').get('newState')
                        lobby.latest_command = {
                            'command': command,
                            'payload': post_data.get('payload'),
                            'timestamp': time.time(),
                            'initiator': lobby.owner
                        }
                self.send_json_response({'success': True})

            else:
                self.send_error_response("Endpoint non trouvé", 404)
        except Exception as e:
            self.send_error_response(str(e))

    def do_GET(self):
        try:
            base_path = self.path.split('?')[0]
            if base_path == '/get_ip':
                ip = get_local_ip()
                qr_code = generate_qr_code(ip, PORT)
                self.send_json_response({
                    "url": f"http://{ip}:{PORT}",
                    "qr_code": qr_code
                })
            elif base_path == '/api/lobbies':
                lobbies_data = []
                with active_sessions_lock:
                    for session in active_sessions.values():
                        lobby_data = session.to_dict()
                        lobby_data['latest_command'] = getattr(session, 'latest_command', None)
                        lobbies_data.append(lobby_data)
                self.send_json_response({'lobbies': lobbies_data})
            elif base_path.startswith('/api/lobby/') and len(base_path.split('/')) == 4:
                room_code = base_path.split('/')[-1]
                with active_sessions_lock:
                    if room_code in active_sessions:
                        lobby = active_sessions[room_code]
                        lobby_data = lobby.to_dict()
                        lobby_data['latest_command'] = getattr(lobby, 'latest_command', None)
                        self.send_json_response(lobby_data)
                    else:
                        self.send_error_response("Salon non trouvé", 404)
            else:
                super().do_GET()
        except Exception as e:
            self.send_error_response(str(e))

    def do_DELETE(self):
        if self.path.startswith('/api/lobby/delete/'):
            room_code = self.path.split('/')[-1]
            with active_sessions_lock:
                if room_code in active_sessions:
                    del active_sessions[room_code]
                    self.send_json_response({'success': True})
                else:
                    self.send_error_response("Le salon n'existe pas", 404)
        else:
            self.send_error_response("Endpoint non trouvé", 404)

def run_server():
    with socketserver.ThreadingTCPServer(("", PORT), LobbyHandler) as httpd:
        httpd.serve_forever()

if __name__ == "__main__":
    run_server()


lobby.py:

import random
import string
import time
import threading
from typing import Dict, Optional
from System.models import LobbySession, User

active_sessions: Dict[str, LobbySession] = {}
active_sessions_lock = threading.Lock()

def generate_code() -> str:
    while True:
        code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=4))
        with active_sessions_lock:
            if code not in active_sessions:
                return code

def create_lobby(player_name: str, password: Optional[str], avatar_index: int, max_players: int, client_ip: str) -> dict:
    if not player_name:
        raise ValueError("Le nom du joueur est requis")
    if max_players not in range(2, 9):
        raise ValueError("Le nombre de joueurs doit être entre 2 et 8")

    room_code = generate_code()
    user_id = str(random.randint(10000, 99999))

    owner = User(
        id=user_id,
        name=player_name,
        avatar_index=avatar_index,
        join_time=time.time(),
        ip_address=client_ip
    )

    lobby_session = LobbySession(
        code=room_code,
        name=f"Salon de {player_name}",
        owner=user_id,
        password=password,
        users={user_id: owner},
        created_at=time.time(),
        max_players=max_players
    )

    with active_sessions_lock:
        active_sessions[room_code] = lobby_session

    return {
        'success': True,
        'roomCode': room_code,
        'userId': user_id,
        'sessionData': lobby_session.to_dict()
    }

def join_lobby(room_code: str, player_name: str, password: Optional[str], avatar_index: int, client_ip: str) -> dict:
    if not room_code or not player_name:
        raise ValueError("Le code du salon et le nom du joueur sont requis")

    with active_sessions_lock:
        if room_code not in active_sessions:
            raise ValueError("Le salon n'existe pas")
        lobby = active_sessions[room_code]

    with lobby.lock:
        if lobby.password and lobby.password != password:
            raise ValueError("Mot de passe incorrect")
        if len(lobby.users) >= lobby.max_players:
            raise ValueError("Le salon est plein")

        user_id = str(random.randint(10000, 99999))
        new_user = User(
            id=user_id,
            name=player_name,
            avatar_index=avatar_index,
            join_time=time.time(),
            ip_address=client_ip
        )

        lobby.users[user_id] = new_user

    return {
        'success': True,
        'userId': user_id,
        'sessionData': lobby.to_dict()
    }

def leave_lobby(user_id: str, room_code: str) -> dict:
    if room_code not in active_sessions:
        return {'success': False, 'error': 'Le salon n\'existe pas'}
    
    lobby = active_sessions[room_code]

    if user_id in lobby.users:
        del lobby.users[user_id]

    if user_id == lobby.owner:
        # Si l'owner quitte, le lobby est supprimé entièrement
        print(f"L'owner du lobby {room_code} a quitté, suppression du lobby.")
        del active_sessions[room_code]
    elif not lobby.users:
        print(f"Le lobby {room_code} est vide et sera supprimé.")
        del active_sessions[room_code]

    return {'success': True}


Lobby_manager.js:

class LobbyManager {
  static POLL_INTERVAL = 1000;
  static MAX_POLL_INTERVAL = 30000;
  static POLL_BACKOFF_FACTOR = 1.5;
  static _currentPollInterval = this.POLL_INTERVAL;
  static _pollTimeout = null;
  static _listeners = new Set();
  static _errorCount = 0;
  static _MAX_ERRORS = 5;

  static init() {
    console.log("[LOBBY_MANAGER] Initialisation...");
    if (localStorage.getItem('roomCode')) {
      this.startPolling();
    }
    this._setupUnloadListener();
  }

  static _setupUnloadListener() {
    window.addEventListener('beforeunload', (event) => {
      const isRedirecting = sessionStorage.getItem('isRedirecting');
      const roomCode = localStorage.getItem('roomCode');
      const userId = localStorage.getItem('userId');
      
      if (!isRedirecting && roomCode && userId) {
        const data = { userId };
        const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
        navigator.sendBeacon(`/api/lobby/${roomCode}/leave`, blob);
        console.log("[LOBBY_MANAGER] Envoi de la requête de sortie via Beacon.");
      }
      sessionStorage.removeItem('isRedirecting'); // Nettoyage
    });
  }

  static async getActivePlayers() {
      console.log("[LOBBY_MANAGER] Récupération des joueurs actifs...");
      const userId = localStorage.getItem('userId');
      const lobby = await this.getCurrentLobby();
      if (lobby) {
          return Object.values(lobby.users)
              .sort((a, b) => a.join_time - b.join_time)
              .map((user) => ({
                  id: user.id,
                  name: user.name,
                  avatar: `/static/images/avatar/${user.avatar_index + 1}.png`,
                  isOwner: user.id === lobby.owner,
                  isCurrentUser: user.id === userId
              }));
      }
      return [];
  }

  static startPolling() {
    if (this._pollTimeout !== null) return;
    console.log("[LOBBY_MANAGER] Début du polling du lobby.");
    this._pollLobby();
  }

  static stopPolling() {
    if (this._pollTimeout) {
      clearTimeout(this._pollTimeout);
      this._pollTimeout = null;
      console.log("[LOBBY_MANAGER] Polling arrêté.");
    }
  }

  static addListener(callback) {
    this._listeners.add(callback);
    return () => this._listeners.delete(callback);
  }

  static async _pollLobby() {
    try {
      const lobby = await this.getCurrentLobby();
      if (lobby) {
        this._errorCount = 0;
        this._currentPollInterval = this.POLL_INTERVAL;
        this._notifyListeners(lobby);
      } else {
        console.error("[LOBBY_MANAGER] Lobby introuvable, arrêt du polling.");
        this.stopPolling();
        return;
      }
    } catch (error) {
      this._errorCount++;
      console.error(`[LOBBY_MANAGER] Erreur lors du polling (${this._errorCount}/${this._MAX_ERRORS}):`, error);
      if (this._errorCount >= this._MAX_ERRORS) {
        console.error("[LOBBY_MANAGER] Nombre maximum d'erreurs atteint. Arrêt du polling.");
        this.stopPolling();
        return;
      }
      this._currentPollInterval = Math.min(
        this._currentPollInterval * this.POLL_BACKOFF_FACTOR,
        this.MAX_POLL_INTERVAL
      );
    } finally {
      if (this._pollTimeout !== null) {
        this._pollTimeout = setTimeout(() => this._pollLobby(), this._currentPollInterval);
      }
    }
  }

  static _notifyListeners(lobby) {
    for (const listener of this._listeners) {
      listener(lobby);
    }
  }

  static async getCurrentLobby() {
    const roomCode = localStorage.getItem('roomCode');
    const userId = localStorage.getItem('userId');
    if (!roomCode || !userId) return null;
    try {
      const response = await fetch(`/api/lobby/${roomCode}`);
      if (!response.ok) {
        if (response.status === 404) {
          console.error("[LOBBY_MANAGER] Lobby non trouvé (404). Nettoyage des données locales.");
          localStorage.removeItem('roomCode');
          localStorage.removeItem('userId');
          this.stopPolling();
        }
        return null;
      }
      const data = await response.json();
      console.log("[LOBBY_MANAGER] Lobby récupéré :", data);
      return {
        ...data,
        isOwner: data.owner === userId,
        currentUser: data.users[userId]
      };
    } catch (error) {
      console.error("[LOBBY_MANAGER] Erreur lors du fetch du lobby:", error);
      return null;
    }
  }

  static async isCurrentUserOwner() {
    const lobby = await this.getCurrentLobby();
    return lobby?.isOwner || false;
  }

  static async leaveLobby() {
    const roomCode = localStorage.getItem('roomCode');
    const userId = localStorage.getItem('userId');
    if (roomCode && userId) {
      try {
        console.log("[LOBBY_MANAGER] Envoi de la requête pour quitter le lobby.");
        await fetch(`/api/lobby/${roomCode}/leave`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userId })
        });
      } catch (error) {
        console.error("[LOBBY_MANAGER] Erreur lors de la demande de sortie du lobby:", error);
      }
    }
    localStorage.removeItem('roomCode');
    localStorage.removeItem('userId');
    this.stopPolling();
  }

  static async sendCommandToPlayers(command, payload = {}) {
    const roomCode = localStorage.getItem('roomCode');
    const lobby = await this.getCurrentLobby();
    
    if (lobby?.isOwner) {  
        try {
            console.log(`[LOBBY_MANAGER] Envoi de la commande '${command}' avec payload:`, payload);
            await fetch(`/api/lobby/${roomCode}/command`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    command,
                    initiator: localStorage.getItem('userId'),
                    payload,
                    timestamp: Date.now()
                })
            });
            console.log(`[LOBBY_MANAGER] Commande '${command}' envoyée avec succès.`);
        } catch (error) {
            console.error("[LOBBY_MANAGER] Erreur lors de l'envoi de la commande:", error);
        }
    } else {
        console.warn("[LOBBY_MANAGER] Seul l'owner peut envoyer des commandes.");
    }
  }

  static async getActivePlayers() {
    const userId = localStorage.getItem('userId');
    const lobby = await this.getCurrentLobby();
    if (lobby) {
        return Object.values(lobby.users)
            .sort((a, b) => a.join_time - b.join_time)
            .map((user) => ({
                id: user.id,
                name: user.name,
                avatar: `/static/images/avatar/${user.avatar_index + 1}.png`,
                isOwner: user.id === lobby.owner,
                isCurrentUser: user.id === userId
            }));
    }
    return [];
}

  static async startGame(gameUrl) {
    const roomCode = localStorage.getItem('roomCode');
    const lobby = await this.getCurrentLobby();
    if (lobby?.isOwner) {
      try {
        console.log("[LOBBY_MANAGER] Lancement de la partie avec l'URL:", gameUrl);
        await fetch(`/api/lobby/${roomCode}/command`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            command: 'start-game',
            initiator: localStorage.getItem('userId'),
            payload: { gameUrl },
            timestamp: Date.now()
          })
        });
      } catch (error) {
        console.error("[LOBBY_MANAGER] Erreur lors du lancement de la partie:", error);
      }
    }
  }
}

export default LobbyManager;


Lobby_redirection.js:

import LobbyManager from './lobby_manager.js';

function setupCommandListener() {
  let lastCommandTime = 0;

  setInterval(async () => {
    try {
      const lobby = await LobbyManager.getCurrentLobby();
      const command = lobby?.latest_command;
      
      if (command && command.timestamp > lastCommandTime) {
        lastCommandTime = command.timestamp;
        
        console.log("[LOBBY_REDIRECTION] Commande reçue :", command);
        switch (command.command) {
          case 'redirect':
            if (shouldRedirect(command.payload.url)) { 
              console.log(`Redirection vers ${command.payload.url}`);
              window.location.href = command.payload.url;
            }
            break;
          case 'lobby-deleted':
            console.log("Nettoyage du lobby...");
            localStorage.removeItem('roomCode');
            localStorage.removeItem('userId');
            LobbyManager.stopPolling();
            window.location.href = 'index.html';
            break;
        }
      }
    } catch (err) {
      console.error("Erreur de traitement :", err);
    }
  }, 1000);
}

export function automaticRedirect(url) {
  if (shouldRedirect(url)) {
    window.location.href = url;
  }
}

export function shouldRedirect(targetUrl) {
  const currentPath = window.location.pathname.split('/').pop();
  const targetPath = new URL(targetUrl, window.location.href).pathname.split('/').pop();
  return currentPath !== targetPath;
}

setupCommandListener();



index.js (where it is used):

// index.js - Script principal pour la page d'accueil / sélection de jeu

import LobbyManager from './lobby_manager.js';
import { automaticRedirect } from './lobby_redirection.js';

document.addEventListener("DOMContentLoaded", async () => {
  const playersContainer = document.getElementById("playersContainer");

  async function updatePlayers() {
    const players = await LobbyManager.getActivePlayers();
    if (players.length === 0 && localStorage.getItem('roomCode')) {
      localStorage.removeItem('roomCode');
      localStorage.removeItem('userId');
      window.location.reload();
      return;
    }
    playersContainer.innerHTML = "";
    players.forEach(player => {
      const playerDiv = document.createElement("div");
      playerDiv.classList.add("player");
      playerDiv.innerHTML = `
        <img src="${player.avatar}" alt="${player.name}" class="player-avatar">
        <span class="player-name">${player.name}${player.isCurrentUser ? ' (Vous)' : ''}${player.isOwner ? ' 👑' : ''}</span>
      `;
      playersContainer.appendChild(playerDiv);
    });
    await updatePreviewButtonState();
  }

  await updatePlayers();
  setInterval(updatePlayers, 5000);

  const introScreen = document.getElementById("introScreen");
  setTimeout(() => {
    introScreen.classList.add("hidden");
    setTimeout(() => {
      introScreen.style.display = "none";
    }, 1000);
  }, 8000);

  const staticSound = document.getElementById("staticSound");
  const staticEffect = document.querySelector(".tv-static");
  const soundToggle = document.getElementById("soundToggle");
  let isMuted = true;
  const audio = new Audio("/static/music/draw-contest.mp3");
  audio.loop = true;

  function updateSoundIcon() {
    soundToggle.innerHTML = isMuted ? `
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
        <line x1="23" y1="9" x2="17" y2="15"></line>
        <line x1="17" y1="9" x2="23" y2="15"></line>
      </svg>` : `
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2">
        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
        <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
        <path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path>
      </svg>`;
  }

  soundToggle.addEventListener("click", () => {
    isMuted = !isMuted;
    if (isMuted) audio.pause();
    else audio.play().catch(console.error);
    updateSoundIcon();
  });
  updateSoundIcon();

  const games = {
    "draw-contest": {
      title: "Dessine moi un Désastre",
      description: "Une phrase loufoque, des dessins absurdes, et un vote pour élire l'œuvre la plus iconique. À vos pinceaux, le massacre commence ! \n4 à 8 Joueurs",
      preview: "/static/images/preview/draw-contest.png",
      music: "/static/music/draw-contest.mp3",
      playerNumber: "3-8"
    },
    "pictionary": {
      title: "Gribouilles & Embrouilles",
      description: "Montrez vos talents artistiques ! Un joueur dessine pendant que les autres se dépêchent de deviner le mot.",
      preview: "/static/images/preview/pictionary.png",
      music: "/static/music/pictionary.mp3",
      playerNumber: "3-8"
    },
    "quiz-rush": {
      title: "Quiz Rush",
      description: "Pensez vite ! Répondez à des questions originales dans ce quiz effréné.",
      preview: "/static/images/preview/quiz-rush.png",
      music: "/static/music/quiz-rush.mp3",
      playerNumber: "2-8"
    },
    "object-tales": {
      title: "La Quête Légendaire",
      description: "Devenez le maître du récit ! Inventez l'histoire la plus drôle ou intrigante à propos d'un objet étrange.",
      preview: "/static/images/preview/object-tales.png",
      music: "/static/music/object-tales.mp3",
      playerNumber: "4-8",
      disabled: true
    }
  };

  async function updatePreviewButtonState() {
    const previewButton = document.getElementById('previewButton');
    const roomCode = localStorage.getItem('roomCode');
    const activeGame = document.querySelector('.game-button.active')?.dataset.game;
    
    if (!roomCode || !activeGame) {
      previewButton.style.display = 'none';
      return;
    }
  
    try {
      const lobby = await LobbyManager.getCurrentLobby();
      const players = await LobbyManager.getActivePlayers();
      const gameInfo = games[activeGame];
      
      // Extraire le nombre minimum de joueurs
      const minPlayers = parseInt(gameInfo.playerNumber.split('-')[0]);
      const isOwner = lobby?.isOwner;
      
      // Vérifier les conditions
      const hasEnoughPlayers = players.length >= minPlayers;
      const shouldShowButton = isOwner && roomCode;
  
      previewButton.style.display = shouldShowButton ? 'flex' : 'none';
      previewButton.disabled = !hasEnoughPlayers;
  
    } catch (error) {
      console.error('Error updating button state:', error);
      previewButton.style.display = 'none';
    }
  }

  setInterval(updatePreviewButtonState, 3000);

  function changeGamePreview(gameId) {
    const game = games[gameId];
    if (!game) return;
    staticEffect.classList.add("show-static");
    staticSound.currentTime = 0;
    staticSound.play();
    setTimeout(() => {
      document.getElementById("previewImage").src = game.preview;
      document.getElementById("previewTitle").textContent = game.title;
      document.getElementById("previewDescription").textContent = game.description;
      document.getElementById("previewPlayerNumber").textContent = game.playerNumber + " Joueurs";
      if (audio.src !== game.music) {
        audio.src = game.music;
        audio.load();
        if (!isMuted) audio.play().catch(console.error);
        updatePreviewButtonState();
      }
      staticEffect.classList.remove("show-static");
    }, 200);
  }

  document.querySelectorAll('.game-button').forEach(button => {
    button.addEventListener("click", () => {
      if (button.disabled) return;
      changeGamePreview(button.dataset.game);
      document.querySelectorAll('.game-button').forEach(btn => btn.classList.remove("active"));
      button.classList.add("active");
    });
  });

  const previewButton = document.querySelector('.preview-button');
    previewButton.addEventListener('click', () => {
    const activeGame = document.querySelector('.game-button.active')?.dataset.game;
    const roomCode = localStorage.getItem('roomCode');
    
    if (activeGame && roomCode) {
      const gameUrl = `/Games/loading/loading.html?game=${activeGame}&roomCode=${roomCode}`;
      automaticRedirect(gameUrl);
    }
  });

  const roomCode = localStorage.getItem("roomCode");
  if (roomCode) {
    document.getElementById("playersContainer").style.display = "flex";
    const createLobbyLink = document.getElementById("createLobbyLink");
    const joinLobbyLink = document.getElementById("joinLobbyLink");
    const creditsLink = document.getElementById("creditsLink");

    const lobby = await LobbyManager.getCurrentLobby();
    const isOwner = lobby?.isOwner || false;

    createLobbyLink.innerHTML = `
      <button class="action-button quit-lobby">
        <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M16 17l5-5-5-5"/>
          <line x1="21" y1="12" x2="9" y2="12"/>
        </svg>
        Quitter
      </button>`;
    joinLobbyLink.innerHTML = `
      <button class="action-button add-players" ${!isOwner ? 'disabled' : ''}>
        <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="12" y1="5" x2="12" y2="19"/>
          <line x1="5" y1="12" x2="19" y2="12"/>
        </svg>
        Ajouter Joueurs
      </button>`;
    creditsLink.innerHTML = `
      <button class="action-button credits">
        <svg class="button-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="8" r="7"></circle>
          <polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>
        </svg>
        Credits
      </button>`;

    createLobbyLink.querySelector('button').addEventListener('click', async () => {
      if (confirm("Êtes-vous sûr de vouloir quitter le lobby ?")) {
        await LobbyManager.leaveLobby();
        window.location.reload();
      }
    });

    joinLobbyLink.querySelector('button').addEventListener('click', () => {
      automaticRedirect('waiting_room.html');
    });

    creditsLink.querySelector('button').addEventListener('click', () => {
      automaticRedirect('credits.html');
    });
  }

  if (roomCode) LobbyManager.startPolling();
});

const roomCode = localStorage.getItem('roomCode');

window.addEventListener('beforeunload', async () => {
  const lobby = await LobbyManager.getCurrentLobby();
  if (lobby?.isOwner) {
    console.log("[INDEX] Owner quitte la page, nettoyage du lobby");
    await LobbyManager.leaveLobby();
  }
});

if (!roomCode) {
  localStorage.removeItem('roomCode');
  localStorage.removeItem('userId');
  LobbyManager.stopPolling();
} else {
  LobbyManager.init();
}

async function loadBottomButtons() {
  try {
    const response = await fetch('button_config.json');
    const config = await response.json();
    const bottomActions = document.getElementById('bottomActions');
    const inLobby = localStorage.getItem('roomCode') ? true : false;
    console.log(`[INDEX] Mode ${inLobby ? "EN LOBBY" : "HORS LOBBY"} – chargement de la configuration des boutons.`);
    const buttons = inLobby ? config.inLobby : config.outLobby;
    bottomActions.innerHTML = '';
    buttons.forEach(btn => {
      const a = document.createElement('a');
      if (btn.link) {
        a.href = btn.link;
      }
      const button = document.createElement('button');
      button.className = 'action-button';
      if (btn.action) button.classList.add(btn.action);
      button.innerHTML = btn.icon + btn.title;
      button.addEventListener('click', async (e) => {
        e.preventDefault();
        console.log(`[INDEX] Bouton cliqué: ${btn.title}`);
        if (inLobby) {
          if (btn.action === 'quit') {
            if (confirm("Êtes-vous sûr de vouloir quitter le lobby ?")) {
              console.log("[INDEX] Quitter le lobby demandé.");
              await LobbyManager.leaveLobby();
              localStorage.removeItem('roomCode');
              window.location.href = 'index.html';
            }
          } else if (btn.action === 'credits') {
            const lobby = await LobbyManager.getCurrentLobby();
            if (lobby && lobby.isOwner) {
              console.log("[INDEX] Owner quittant le lobby pour accéder aux Credits.");
              await LobbyManager.sendCommandToPlayers('redirect', { url: `credits.html?roomCode=${roomCode}` });
              window.location.href = `credits.html?roomCode=${roomCode}`;
            } else {
              console.log("[INDEX] Redirection automatique vers Credits pour non-owner.");
              automaticRedirect(`credits.html?roomCode=${roomCode}`);
            }
          } else if (btn.action === 'waiting') {
            console.log("[INDEX] Owner envoie une commande pour que tout le monde aille en salle d'attente.");
            await LobbyManager.sendCommandToPlayers('redirect', { url: `waiting_room.html?roomCode=${roomCode}` });
            window.location.href = `waiting_room.html?roomCode=${roomCode}`;
          } else if (btn.link) {
            console.log(`[INDEX] Redirection vers ${btn.link}`);
            window.location.href = btn.link;
          }
        } else {
          if (btn.link) {
            console.log(`[INDEX] Redirection vers ${btn.link} (mode hors lobby)`);
            window.location.href = btn.link;
          }
        }
      });
      a.appendChild(button);
      bottomActions.appendChild(a);
    });
  } catch (error) {
    console.error("[INDEX] Erreur lors du chargement des boutons:", error);
  }
}

// Vérifie si l'intro a déjà été vue
document.addEventListener("DOMContentLoaded", function() {
  if (localStorage.getItem('introSeen')) {
    document.getElementById('introScreen').style.display = 'none';
  } else {
    localStorage.setItem('introSeen', 'true');
  }
});

loadBottomButtons();